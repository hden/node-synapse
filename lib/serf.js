// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var Parser, Q, Readline, debug, exec, execPromise, print, stream, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  exec = require('child_process').exec;

  stream = require('stream');

  _ = require('underscore');

  debug = require('debug');

  Q = require('q');

  print = debug('serf');

  Readline = (function(_super) {
    __extends(Readline, _super);

    function Readline() {
      this._transform = __bind(this._transform, this);
      Readline.__super__.constructor.apply(this, arguments);
      this._cache = '';
    }

    Readline.prototype._transform = function(chunk, encoding, done) {
      var lines, _i, _ref;
      if (encoding == null) {
        encoding = 'utf-8';
      }
      this._cache += chunk.toString(encoding);
      _ref = this._cache.split('\n'), lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this._cache = _ref[_i++];
      lines.forEach(this.push.bind(this));
      return done();
    };

    return Readline;

  })(stream.Transform);

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser() {
      this._transform = __bind(this._transform, this);
      Parser.__super__.constructor.apply(this, arguments);
      this._readableState.objectMode = true;
      this._writableState.objectMode = true;
    }

    Parser.prototype._transform = function(line, encoding, done) {
      if (encoding == null) {
        encoding = 'utf-8';
      }
      line = line.toString(encoding);
      if (line.match('EventMember')) {
        this.push(exports.members());
      } else {
        this.push(Q.when(line));
      }
      return done();
    };

    return Parser;

  })(stream.Transform);

  execPromise = function(command) {
    var deferred;
    deferred = Q.defer();
    exec(command, function(err, stdout, stderr) {
      if (err != null) {
        print("node err: " + err);
        deferred.reject(err);
      }
      if (stderr.length > 0) {
        print("stderr: " + stderr);
        deferred.reject(stderr);
      }
      print("stdout: " + stdout);
      return deferred.resolve(stdout);
    });
    return deferred.promise;
  };

  exports.start = function(options) {
    var flags, preset, readline, stderr, stdin, stdout, _ref;
    if (options == null) {
      options = {};
    }
    preset = {
      node: 'nobody',
      role: 'minion',
      bind: '0.0.0.0:7946',
      encrypt: 'yvaS3kB4u9t164qpsOYitQ=='
    };
    _.defaults(options, preset);
    flags = _.map(options, function(v, k) {
      return "-" + k + " " + v + " ";
    });
    _ref = exec("serf agent " + (flags.join(''))), stdout = _ref.stdout, stdin = _ref.stdin, stderr = _ref.stderr;
    readline = new Readline();
    stdout.pipe(readline).pipe(parser).on('data', function(promise) {
      return promise.then(function(d) {
        return print(JSON.stringify(d, null, 4));
      });
    });
    return Q.when;
  };

  exports.members = function(options) {
    var deferred;
    if (options == null) {
      options = '-status alive';
    }
    print('members');
    deferred = Q.defer();
    return execPromise("serf members " + options).then(function(stdout) {
      return _.chain(stdout.split('\n')).compact().map(function(line) {
        var address, name, role, status, _ref;
        _ref = line.split(/\ +/), name = _ref[0], address = _ref[1], status = _ref[2], role = _ref[3];
        return {
          name: name,
          address: address,
          status: status,
          role: role
        };
      }).value();
    });
  };

  exports.leave = function() {
    return execPromise('serf leave');
  };

  exports.join = function(address) {
    if (address == null) {
      address = '';
    }
    return execPromise("serf join " + address);
  };

  exports.event = function(event, payload) {
    if (event == null) {
      event = 'test';
    }
    if (payload == null) {
      payload = '';
    }
    if (!_.isString(payload)) {
      payload = JSON.stringify(payload);
    }
    return execPromise("serf event " + event + " " + payload);
  };

}).call(this);
